"""
Plotting Overview
=================

This tutorial gives an overview of the plotting capabilities of NAVis. We will cover 2D
and 3D plotting with various backends and their pro's and con's.

{{ navis }} contains functions for (static) 2D and (interactive) 3D plotting. These functions
can use various different backends for plotting. For 2D plots we use [`matplotlib`](http://www.matplotlib.org)
and for 3D plots we use either [`octarine`](https://schlegelp.github.io/octarine/),
[`vispy`](http://www.vispy.org), [`plotly`](http://plot.ly) or [`k3d`](https://k3d-jupyter.org).

Which plotting method (2D/3D) and which backend (octarine, plotly, etc.) to use depends on
what you are after (e.g. static, publication quality figures vs interactive data exploration)
and your environment (e.g. Jupyter/VS code or terminal). Here's a quick summary:

| Backend    | Used in              | Pros                                                                 | Cons                                                                                      |
|------------|----------------------|----------------------------------------------------------------------|-------------------------------------------------------------------------------------------|
| matplotlib | [`navis.plot2d`][]<br>[`navis.plot1d`][]<br>[`navis.plot_flat`][]   | - high quality (vector graphics!)<br>- works in Jupyter and terminal<br>- exports to vector graphics<br>- myriads of ways to adjust plots | - struggles with correct depth layering in complex scenes<br>- not very interactive (although you can adjust perspective)<br> - slow for large scenes<br>- not good for voxel data (e.g. image volumes) |
| octarine   | [`navis.plot3d`][]   | - blazingly fast thanks to WGPU backend<br>- works in terminal and Jupyter<br>- very interactive | - may not work on older systems (use `vispy` instead)<br>- not persistent (i.e. dies with notebook kernel)<br>- can't share interactive plot (screenshots only) |
| vispy      | [`navis.plot3d`][]   | - very interactive<br>- good render quality and performance    | - can't share interactive plot (screenshots only)<br>- not persistent (i.e. dies with notebook kernel)<br>- deprecated in favor of octarine |
| plotly     | [`navis.plot3d`][]   | - works "inline" for Jupyter environments<br>- persistent (i.e. plots get saved alongside notebook)<br>- can produce offline HTML plots for sharing  | - not very fast for large scenes<br>- large file sizes (i.e. makes for large `.ipynb` notebook files)<br>- horrendous for voxel data (i.e. images) |
| k3d        | [`navis.plot3d`][]   | - works "inline" for Jupyter environments<br>- super fast and performant<br>- in memory (i.e. does not increase notebook file size) | - does not work in terminal sessions<br>- not persistent (i.e. dies with notebook kernel)<br>- can't share interactive plot (screenshots only) |

In theory there is feature parity across backends but due to built-in limitations there are minor differences.

If you installed NAVis via `pip install navis[all]` all of the above backends should be available to you.
If you ran a minimal install (`pip install navis`) you may need to install the backends separately
- NAVis will complain if you try to use a backend that is not installed!

!!! note

    The plots in this tutorial are optimized for light-mode. If you are using dark-mode, you may not see some details.

## 2D plots

This uses `matplotlib` to generate static 2D plots. The big advantage is that you can save these plots as vector graphics.
Unfortunately, matplotlib's capabilities regarding 3D data are limited. The main problem is that depth (z) is only
simulated by trying to layer objects (lines, vertices, etc.) according to their z-order rather than doing proper rendering which
is why you might see some neurons being plotted in front of others even though they are actually behind them. It's still great
for plotting individual neurons or small groups thereof!

Let's demonstrate with a simple example using the default settings:
"""

# %%
import navis
import matplotlib.pyplot as plt

nl = navis.example_neurons(kind="skeleton")

# Plot using default settings
fig, ax = navis.plot2d(nl, view=("x", "-z"), method="2d")

# %%
# !!! note
#     We set `view("x", "-z")` above to get a frontal view of the example neurons. You may need to adjust this depending on
#     the orientation of your neurons.
#
# Above plot used the default `matplotlib` 2D plot. You might notice that the plot looks rather "flat" - i.e. neurons seem
# to be layered on top of each other without intertwining. That is one of the limitations of `matplotlib`'s 3d backend.
# We can try to ameliorate this by adjust the `method` parameter:

# Plot settings for more complex scenes - comes at a small performance cut though
fig, ax = navis.plot2d(nl, method="3d_complex", view=("x", "-z"))

# %%
# Looks better now, doesn't it? Now what if we wanted to adjust the perspective? For 3d axes, `matplotlib` lets
# us adjust the viewing angle by setting the `elev`, `azim` and `roll` attributes.
# See also [this official explanation](https://matplotlib.org/stable/api/toolkits/mplot3d/view_angles.html).
#
# Let's give that a shot:

# %%
# Plot again
fig, ax = nl.plot2d(method="3d_complex", view=("x", "-z"), non_view_axes3d="show")

# Change view to see the neurons from a different angle
ax.elev = -20
ax.azim = 45
ax.roll = 180

# %%
# !!! note
#     Did you note that we set `non_view_axes3d='show'` in above example? By default, { navis } hides the axis that is parallel to
#     the viewing direction is hidden to not clutter the image. Because we were going to change the perspective,
#     we set it to `show`. FYI: if the plot is rendered in a separate window (e.g. if you run Python from
#     terminal), you can change the perspective by dragging the image.
#
# We can use this to generate small animations:
#
# ```python
# # Render 3D rotation
# for i in range(0, 360, 10):
#    # Change rotation
#    ax.azim = i
#    # Save each incremental rotation as frame
#    plt.savefig('frame_{0}.png'.format(i), dpi=200)
# ```
#
# ![rotation](../../../../_static/rotation.gif)
#
# You may have noticed that our example neurons `nl` are skeletons but still they look pretty solid in the plots.
# That's because by default `plot2d` uses their radius (if present) to turn the skeletons into cylinders.
# That can slow things down quite a bit, so if you have a lot of neurons to plot and don't care about the
# radius, you can set `radius=False`:

# %%

# Setting `radius=False` will plot skeletons as lines which is much faster
fig, ax = nl.plot2d(method="3d_complex", view=("x", "-z"), radius=False)

# %%
# ## Plotting meshes
#
# We can also plot meshes (`MeshNeurons`, `trimesh`, or `Volumes`) using `matplotlib`. To illustrate, we will
# use one of the neuropil meshes that ship with {{ navis }}:

# %%
# Load the Lateral Horn ("LH") volume
lh = navis.example_volume("LH")

# Adjust color and alpha if you like
lh.color = (
    0.8,
    0.8,
    0.8,
    0.2,
)  # alternatively you can set the color to a string like 'green'

# Plot
fig, ax = navis.plot2d([nl, lh], method="3d_complex", view=("x", "-z"))

# %%
# We can also plot just the volume's outline by setting `volume_outlines=True` (only works for method '2d' though):

# Give it a darker color
lh.color = "k"

fig, ax = navis.plot2d(
    [nl, lh],
    method="2d",  # outline work only with the 2d
    view=("x", "-z"),
    volume_outlines=True,  # set `volume_outlines="both"` to see both outlines and filled volume
)

# %%
# !!! note
#     In our examples we're using [`navis.plot2d(nl)`][navis.plot2d]. Alternatively, you can also use the
#     [`NeuronList`][navis.NeuronList] short-hand method: [`nl.plot2d()`][navis.NeuronList.plot3d] for a
#     quick visualization:
#     ```python
#     nl.plot2d(method='3d_complex', view=('x', '-z'))
#     ```
#
# ## Fine-tuning plots
# These 2D plots (and also the 3D plots further down) can be adjusted and fine-tuned to your liking.
#
# ### Changing colors
#
# {{ navis }} [`plot3d`][navis.plot3d] and [`plot2d`][navis.plot2d] accept various ways to specify colors for neurons.
# We'll demonstrate this using some examples.
#
# Same color for all neurons:

fig, ax = navis.plot2d(nl, view=("x", "-z"), method="3d_complex", color=(1, 0, 0))

# %%
# Passing a list of colors, one for each neuron:

fig, ax = navis.plot2d(
    nl, view=("x", "-z"), method="3d_complex", color=["r", "g", "b", "m", "c"]
)

# %%
# You can map colors to neurons by either using the neuron itself, its `.id` or its `.name` attribute.

cmap = {
    nl[0]: "r",  # index by neuron
    nl[1].id: (0, 1, 0),  # index by id
    nl[2].name: "g",  # index by name
    nl[3]: "m",  # index by neuron
    nl[4]: "k",
}  # index by neuron

fig, ax = navis.plot2d(nl, view=("x", "-z"), method="3d_complex", color=cmap)

# %%
# You can also use the `palette` parameter to specify a color palette (e.g. 'viridis').
# If you pass a list of colors, the colors will be mapped to neurons in the order they appear in the neuron list.

# %%
fig, ax = navis.plot2d(nl, view=("x", "-z"), method="3d_complex", palette="Reds")

# %%
# [`navis.Volume`][] colors work similarly with the difference that the fallback color is defined by the `.color` attribute of the volume:

lh = navis.example_volume("LH")

# Set color implicitly
lh.color = (0.8, 0.8, 0.8, 0.2)

fig, ax = navis.plot2d([nl, lh], view=("x", "-z"), method="3d_complex")

# %%
# ## Adjusting lines
#
# [`navis.plot2d`][] accepts a range of parameters to fine-tune plots. See these examples:
#
# ### Change linewidth

fig, ax = navis.plot2d(
    nl,
    view=("x", "-z"),
    method="3d_complex",
    radius=False,  # plot as skeletons (i.e. without radius)
    linewidth=2,  # default linewidth is 1
)

# %%
# When you use `radius=True` (default), the `linewidth` parameter can be used to scale the radius:

fig, ax = navis.plot2d(
    nl,
    view=("x", "-z"),
    method="3d_complex",
    radius=True,  # plot as tube (i.e. with radius)
    linewidth=0.5,  # default linewidth is 1, so this would make neurons slightly thinner
)

# %%
# We can also change line style:

# %%
fig, ax = navis.plot2d(
    nl,
    view=("x", "-z"),
    method="3d_complex",
    radius=False,  # plot as skeletons (i.e. without radius)
    linestyle="--",
)

# %%
# Change the opacity:

# %%
fig, ax = navis.plot2d(nl, view=("x", "-z"), method="3d_complex", alpha=0.25)

# %%
# ### Depth-coloring
#
# To facilitate perception of depth in 2D plots, [`navis.plot2d`][] can color neurons based on their z-depth.
# This is only available for `method="2d"` and `method="3d"` but not `method="3d_complex"`.
#
# With ``method="2d"``:
#

fig, ax = navis.plot2d(
    nl[0],
    method="2d",
    linewidth=1.5,
    radius=True,
    depth_coloring=True,
    view=("x", "-z"),
)

# %%
# ## Shading
#
# In the above example we colored individual nodes based on their z-depth. We can use the same mechanics to apply our own color scheme.
# For example, let's color branches based on their [Strahler order](https://en.wikipedia.org/wiki/Strahler_number).

# Fist calculate Strahler indices
n = nl[0].reroot(nl[0].soma)
navis.strahler_index(n)

# Note the new column in the node table?
n.nodes.head()

# %%
# Both [`plot2d`][navis.plot2d] and [`plot3d`][navis.plot3d] accept `color_by` and `shade_by` parameters. These can either be arrays
# (same length as node table) or point to a column in the node table. They can deal with numeric and categorical variables which will be
# translated into colors using a given `palette` and alpha values, respectively.

fig, ax = navis.plot2d(
    n,
    method="3d",
    color_by="strahler_index",  # color based on Strahler index column
    shade_by="strahler_index",  # shade (alpha) based on Strahler index column
    palette="cool",  # accepts any matplotlib palette
    radius=True,
    view=("x", "-z"),
)

# %%
# ## 3D plots
#
# As laid out at the top of this page: for 3D plots, we are using either [octarine](https://schlegelp.github.io/octarine/),
# [vispy](https://github.com/vispy/vispy), [plotly](https://plotly.com/) or [k3d](https://k3d-jupyter.org). In brief:
#
# | backend             | Jupyter | terminal |
# |---------------------|---------|----------|
# | octarine            | yes     | yes      |
# | plotly              | yes     | yes but only via export to html |
# | vispy (depcrecated) | yes     | yes      |
# | k3d                 | yes     | no       |
#
# ```python
# # Plot using Octarine
# viewer = navis.plot3d(nl, radius=True, backend='octarine')
#
# # In Jupyter, we have to explicitly call the .show() method *in the last line of the cell* for the widget to be displayed
# viewer.show()
# ```
#
# ![octarine](../../../../_static/octarine_viewer.png)
#
# A few important notes regarding Octarine:
#
# - The `viewer` is dynamic: you can keep adding/removing items in other cells. However, it will die with the kernel (unlike `plotly`)!
# - By default, {{ navis }} will track the "primary" viewer and subsequent calls of [`navis.plot3d`][] will add to that primary viewer.
#   If you want to force a new viewer, call `navis.plot3d(nl, viewer='new')`.
# - You can resize the canvas by dragging the lower right corner
# - The rendering runs in your Jupyter Kernel and the frames are sent to Jupyter via a remote frame buffer (`jupyter_rbf`). If your
#   Jupyter kernel runs on a remote machine you might experiences some lag depending on the connection speed and quality.
#
# ```python
# # Clear existing viewer
# navis.close3d()
#
# # Add neurons to viewer
# navis.plot3d(nl, backend='octarine')
#
# # Add volume
# navis.plot3d(lh, backend='octarine')
#
# # Clear viewer again...
# navis.clear3d()
#
# # ... or close altogether
# navis.close3d()
# ```

# %%
# The Octarine viewer itsel has a bunch of neat features - check out the [documentation](https://schlegelp.github.io/octarine/) to learn more.
#
# Vispy works similar in that it also works via a `viewer` object to which you can add objects. Try running this in a terminal:
#
# ```python
# import navis
#
# nl = navis.example_neurons(kind='mesh')
#
# v = navis.plot3d(nl, backend='vispy')
# # If the viewer doesn't appear, try `v.show()`
# ```
#
# ![vispy](../../../../_static/vispy_viewer.png)
#
# The [`navis.Viewer`][] (`viewer` here) has similar functionality to the Octarine viewer - e.g. [`navis.close3d`][]
# [`navis.clear3d`][] will work too.
#
# !!! important
#     The Vispy backend is deprecated and will be removed in future versions of {{ navis }}. If you can please switch to Octarine.
#     If you have any issues with Octarine and want us to keep the Vispy backend, please let us know!

# %%
# ## Using k3d
#
# `k3d` plots work in Jupyter (and only there) but unlike `plotly` don't persist across sessions. Hence we will only briefly demo
# them using static screenshots and then move on to plotly. Almost everything you can do with the `plotly` backend can also be done
# with `k3d` (or `vispy` for that matter)!

# %%
p = navis.plot3d(nl, backend="k3d")

# %%
# ![k3d](../../../../_static/k3d_viewer.png)
#
# ## Using plotly
#
# Now let's have a look at Plotly as backend:
#
# Using plotly as backend generates "inline" plots by default (i.e. they are rendered right away):

nl.plot3d(backend="plotly", connectors=False)

# %%
# Instead of inline plotting, you can also export your plotly plot as 3D plot that can be opened in any browser:
#
# ```python
# import plotly
#
# # Prevent inline plotting
# fig = nl.plot3d(backend='plotly', connectors=False, width=1400, height=1000, inline=False)
#
# # Save figure to html file
# plotly.offline.plot(fig, filename='~/Documents/3d_plot.html')
# ```
#
# So far, we've been plotting skeletons (i.e. [`navis.TreeNeuron`][]). [`navis.MeshNeurons`][navis.MeshNeuron] work pretty much the same:
#

ml = navis.example_neurons(kind="mesh")
ml.plot3d(backend="plotly", connectors=False)

# %%
# ## Navigating the 3D viewer
#
# 1. Rotating: Hold left mousebutton and drag
# 2. Zooming: Use the mousewheel or press Alt and drag
# 3. Panning: Hold right mousebutton and drag
# 4. Hide/unhide: Click legend
#
# !!! note "Camera rotation"
#     If the camera rotation using plotly causes problems, try clicking on the "Orbital rotation" in the upper right ModeBar.
#
# ## Adding volumes
#
# We've already seen this in [`plot2d`][navis.plot2d] but [`plot3d`][navis.plot3d] of course also allows plotting of volumes (e.g. neuropil meshes).
#
# !!! note
#     There is a custom class for Volumes, [`navis.Volume`][], which has some neat methods including loading from different file formats
#     - check out the documentation.
#

# Load two example volumes
vols = [navis.example_volume("LH"), navis.example_volume("neuropil")]
navis.plot3d([nl, *vols], backend="plotly")

# %%
# ## Fine-tuning plots
# Just like the 2D plots, there are plenty ways to adjust these 3D plots. In fact, pretty much everything (except some of the line styling)
# show-cased earlier works just the same way for 3D plots:
#
# Changing colors:

n = navis.example_neurons(1, kind="mesh")

navis.plot3d(n, color="r", backend="plotly")

# %%
# Coloring by e.g. Strahler index:

n = navis.example_neurons(1, kind="skeleton")

# This adds an `.strahler_index` array with the values to this MeshNeuron
navis.strahler_index(n)

# Plot with color based on Strahler index
navis.plot3d(
    n,
    color_by="strahler_index",
    palette="viridis",
    backend="plotly",
    radius=False,
    linewidth=5,
)

# %%
# ## Videos
#
# Above we demo'ed making a little GIF using matplotlib. While that's certainly fun, it's not
# very high production value. For high quality videos (and renderings) I recommend you check out
# the tutorial on navis' Blender :ref:`interface <blender3d>`. Here's a little taster:
#
#  <iframe width="560" height="315" src="https://www.youtube.com/embed/wl3sFG7WQJc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
#
# ## XKCD
#
# If you don't already know: `matplotlib` has a
# [xkcd mode](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.xkcd.html).
# This also works surprisingly well with neurons:

# %%

# Get the neuropil volume
m = navis.example_volume("neuropil")

# Make it fairly transparent
m.color = (0, 0, 0, 0.02)

# Plot in xkcd style
with plt.xkcd(scale=5, randomness=10, length=200):
    fig, ax = navis.plot2d(
        [nl, m], method="2d", c="k", view=("x", "-z"), lw=1.2, volume_outlines="both"
    )
