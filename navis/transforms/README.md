# Transforms
The landscape between template (brains), different types of transforms and
bridging sequences is fairly complex. This document will attempt to give a brief
overview to disentangle this. Because I work with Drosophila (fruit flies)
examples will be insect-centric but navis is general-purpose.

`navis` also does not ship with any transform/template data as these are
typically large-ish files. Check out
[flybrains](https://github.com/schlegelp/navis-flybrains) as an example of
how to make data available to navis transforms.

## Terminology
### Template
Very generally speaking, "templates" or "template brains" refer to landmark
brains. These can be artificial templates generated by averaging across multiple
brains (e.g. the JRC2018U fly template brain, Bogovic et al. 2018), or single
brains (e.g. the FAFB EM volume).

## Transforms
Transforms come in two flavours:
  1. Bridging transforms that transform data from one template to another. For
     example, JRC2018U to FAFB.
  2. Mirror transforms that compensate for left/right asymmetries within a
     template brain. The basic idea is that after applying a mirror transform,
     left and right versions of the same neuron should look identical (albeit
     flipped obviously).

In addition to these flavours, transforms can be off different types. Off the
bat, navis supports 4 types of transforms:
  1. `navis.transforms.affine.AffineTransform` implements simple rigid affine
     transforms (scale, shear, offset, etc.).
  2. `navis.transforms.thinplate.TPStransform` implements thin-plate spine
     transforms: given the same set of landmarks in two different template
     spaces it will calculate and apply a thin-plate spine transform.
  3. `navis.transforms.cmtk.CMTKtransform` provides an interface with
     [CMTK](https://www.nitrc.org/projects/cmtk/) to use CMTK's `.list`
     transforms. CMTK needs to be installed separately.
  4. `navis.transforms.h5reg.H5transform` provides an interface to use the
     Saalfeld lab's h5 deformation field-based transforms. 

You can subclass ``navis.transforms.base.BaseTransform`` to implement other
types of transforms for navis to use.

## Transform sequences
In an ideal scenario, you a single transform might get you from template A
to template B. However, in cases where there is no direct transform A->B
you might find an indirect path via C. This requires us to perform a sequence
of transforms: A to C followed by C to B.

# Registry
To plot transform sequences, navis has to know about the available transforms.
That's what `navis.transforms.registry` is for: it keeps track of transforms,
templates and plots paths to get from A to B.

On import, the `registry` scans paths set in an `NAVIS_TRANSFORMS` environment
variable for transform files/directories it understands (`.h5`, '.list').
Alternatively, you can add more paths via `registry.register_path()` or add
already constructed transforms via ``registry.add_transforms()``.
